---
phase: 12-settings-panel-ui
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/components/settings/settings-panel.tsx
autonomous: true

must_haves:
  truths:
    - "Settings panel displays 4 provider options in Providers tab"
    - "Clicking OpenAI Compatible or OpenRouter button updates llm_provider state"
    - "Test button appears and functions for OpenAI-compatible provider"
    - "Test button appears and functions for OpenRouter provider"
    - "Successfully tested providers populate model lists"
  artifacts:
    - path: "frontend/components/settings/settings-panel.tsx"
      provides: "Extended Settings interface and provider infrastructure"
      contains: "openai_compatible.*openrouter"
  key_links:
    - from: "settings-panel.tsx"
      to: "/api/setup/test-openai-compatible"
      via: "testOpenAICompatible function"
      pattern: "fetch.*test-openai-compatible"
    - from: "settings-panel.tsx"
      to: "/api/setup/test-openrouter"
      via: "testOpenRouter function"
      pattern: "fetch.*test-openrouter"
---

<objective>
Extend settings panel infrastructure to support OpenAI-compatible and OpenRouter providers.

Purpose: Enable the settings panel to recognize and test both new provider types before building their configuration forms.
Output: Settings interface extended, 4-provider toggle buttons, test functions wired to existing backend endpoints.
</objective>

<execution_context>
@/Users/mmaudet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mmaudet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-settings-panel-ui/12-RESEARCH.md
@frontend/components/settings/settings-panel.tsx
@frontend/components/setup/provider-step.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend Settings interface and DEFAULT_SETTINGS</name>
  <files>frontend/components/settings/settings-panel.tsx</files>
  <action>
Update the Settings interface to include new provider types and fields:

1. Update llm_provider union type:
   ```typescript
   llm_provider: 'ollama' | 'groq' | 'openai_compatible' | 'openrouter';
   ```

2. Add new fields to Settings interface (after groq_model):
   ```typescript
   // OpenAI-compatible
   openai_base_url: string;
   openai_api_key: string;
   openai_model: string;
   // OpenRouter
   openrouter_api_key: string;
   openrouter_model: string;
   ```

3. Add corresponding defaults to DEFAULT_SETTINGS constant (after groq_model):
   ```typescript
   openai_base_url: '',
   openai_api_key: '',
   openai_model: '',
   openrouter_api_key: '',
   openrouter_model: '',
   ```

Note: Empty string defaults match existing pattern and Phase 9 backend defaults.
  </action>
  <verify>TypeScript compiles without errors: `cd frontend && pnpm build 2>&1 | head -50`</verify>
  <done>Settings interface includes all 5 new fields with proper typing, DEFAULT_SETTINGS has matching empty string defaults</done>
</task>

<task type="auto">
  <name>Task 2: Add test state and functions for new providers</name>
  <files>frontend/components/settings/settings-panel.tsx</files>
  <action>
Add state and test functions following existing Ollama/Groq patterns.

1. Add state declarations (after groqModels state):
   ```typescript
   const [openaiModels, setOpenaiModels] = useState<string[]>([]);
   const [openrouterModels, setOpenrouterModels] = useState<string[]>([]);
   ```

2. Add test status state (after groqTest state):
   ```typescript
   const [openaiTest, setOpenaiTest] = useState<{ status: TestStatus; error: string | null }>({
     status: 'idle',
     error: null,
   });
   const [openrouterTest, setOpenrouterTest] = useState<{ status: TestStatus; error: string | null }>({
     status: 'idle',
     error: null,
   });
   ```

3. Add testOpenAICompatible function (after testGroq):
   ```typescript
   const testOpenAICompatible = useCallback(async () => {
     if (!settings.openai_base_url) return;
     setOpenaiTest({ status: 'testing', error: null });

     try {
       const res = await fetch('/api/setup/test-openai-compatible', {
         method: 'POST',
         headers: { 'Content-Type': 'application/json' },
         body: JSON.stringify({
           base_url: settings.openai_base_url,
           api_key: settings.openai_api_key,
         }),
       });
       const result = await res.json();

       if (result.success) {
         setOpenaiTest({ status: 'success', error: null });
         setOpenaiModels(result.models || []);
         if (!settings.openai_model && result.models?.length > 0) {
           setSettings((s) => ({ ...s, openai_model: result.models[0] }));
         }
       } else {
         setOpenaiTest({ status: 'error', error: result.error || t('errors.connectionFailed') });
       }
     } catch {
       setOpenaiTest({ status: 'error', error: t('errors.connectionFailed') });
     }
   }, [settings.openai_base_url, settings.openai_api_key, settings.openai_model, t]);
   ```

4. Add testOpenRouter function (after testOpenAICompatible):
   ```typescript
   const testOpenRouter = useCallback(async () => {
     if (!settings.openrouter_api_key) return;
     setOpenrouterTest({ status: 'testing', error: null });

     try {
       const res = await fetch('/api/setup/test-openrouter', {
         method: 'POST',
         headers: { 'Content-Type': 'application/json' },
         body: JSON.stringify({ api_key: settings.openrouter_api_key }),
       });
       const result = await res.json();

       if (result.success) {
         setOpenrouterTest({ status: 'success', error: null });
         setOpenrouterModels(result.models || []);
         if (!settings.openrouter_model && result.models?.length > 0) {
           setSettings((s) => ({ ...s, openrouter_model: result.models[0] }));
         }
       } else {
         setOpenrouterTest({ status: 'error', error: result.error || t('errors.invalidApiKey') });
       }
     } catch {
       setOpenrouterTest({ status: 'error', error: t('errors.failedToValidate') });
     }
   }, [settings.openrouter_api_key, settings.openrouter_model, t]);
   ```

5. Add auto-fetch useEffects (after the existing Groq auto-fetch useEffect):
   ```typescript
   // Auto-fetch OpenRouter models when API key is available and models not yet loaded
   useEffect(() => {
     if (isOpen && settings.openrouter_api_key && openrouterModels.length === 0 && !loading) {
       testOpenRouter();
     }
   }, [isOpen, settings.openrouter_api_key, openrouterModels.length, loading, testOpenRouter]);
   ```

Note: OpenAI-compatible does not auto-fetch since base_url varies and needs explicit test.
  </action>
  <verify>TypeScript compiles without errors: `cd frontend && pnpm build 2>&1 | head -50`</verify>
  <done>Test functions for both providers exist, call correct endpoints, update state appropriately, auto-fetch for OpenRouter works</done>
</task>

<task type="auto">
  <name>Task 3: Update provider toggle to 4 buttons with wrapping layout</name>
  <files>frontend/components/settings/settings-panel.tsx</files>
  <action>
Update renderProvidersTab() to display 4 provider buttons with proper layout.

Replace the existing inline-flex provider toggle section with flex-wrap layout:

```tsx
<div
  className="flex flex-wrap gap-2 rounded-xl p-1"
  style={{ background: 'rgb(from var(--surface-2) r g b / 0.5)' }}
>
  <button
    onClick={() =>
      setSettings({
        ...settings,
        llm_provider: 'ollama',
      } as Settings)
    }
    className={`rounded-md px-4 py-2 text-sm font-medium transition-colors ${
      settings.llm_provider === 'ollama'
        ? 'bg-background text-foreground shadow'
        : 'text-muted-foreground hover:text-foreground'
    }`}
  >
    Ollama
  </button>
  <button
    onClick={() =>
      setSettings({ ...settings, llm_provider: 'groq' } as Settings)
    }
    className={`rounded-md px-4 py-2 text-sm font-medium transition-colors ${
      settings.llm_provider === 'groq'
        ? 'bg-background text-foreground shadow'
        : 'text-muted-foreground hover:text-foreground'
    }`}
  >
    Groq
  </button>
  <button
    onClick={() =>
      setSettings({ ...settings, llm_provider: 'openai_compatible' } as Settings)
    }
    className={`rounded-md px-4 py-2 text-sm font-medium transition-colors ${
      settings.llm_provider === 'openai_compatible'
        ? 'bg-background text-foreground shadow'
        : 'text-muted-foreground hover:text-foreground'
    }`}
  >
    OpenAI Compatible
  </button>
  <button
    onClick={() =>
      setSettings({ ...settings, llm_provider: 'openrouter' } as Settings)
    }
    className={`rounded-md px-4 py-2 text-sm font-medium transition-colors ${
      settings.llm_provider === 'openrouter'
        ? 'bg-background text-foreground shadow'
        : 'text-muted-foreground hover:text-foreground'
    }`}
  >
    OpenRouter
  </button>
</div>
```

Note: Removed stt_provider auto-setting from buttons - this will be handled elsewhere. Using flex-wrap allows buttons to wrap on mobile.
  </action>
  <verify>TypeScript compiles: `cd frontend && pnpm build 2>&1 | head -50`</verify>
  <done>Provider toggle shows 4 buttons, clicking any button updates llm_provider state, layout wraps on small screens</done>
</task>

</tasks>

<verification>
1. `cd frontend && pnpm build` completes without TypeScript errors
2. `cd frontend && pnpm lint` passes
3. Settings interface includes all new fields
4. DEFAULT_SETTINGS has matching defaults
5. Test functions exist and reference correct endpoints
</verification>

<success_criteria>
- Settings interface extended with openai_compatible and openrouter provider types
- 5 new settings fields (openai_base_url, openai_api_key, openai_model, openrouter_api_key, openrouter_model)
- Test state and functions for both new providers
- 4 provider buttons visible in toggle
- TypeScript compiles successfully
</success_criteria>

<output>
After completion, create `.planning/phases/12-settings-panel-ui/12-01-SUMMARY.md`
</output>
